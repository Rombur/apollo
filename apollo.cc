/*
 * This program creates an silo file for unstructured meshes. The program
 * needs to three arguments: the type of input file, the name of the input 
 * file, and the name of the output file. The input file must have the following 
 * structure: number of cells, numbers of nodes, numbers of values of flux 
 * moments (multiple of the number of nodes), the offset vector (position 
 * of the first node of cell 1, position of the first node of cell 2, ..., 
 * number of nodes), coordinates (x,y) of the nodes, value of the flux moments 
 * at each nodes.
 */

#include <algorithm>
#include <cassert>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include "POST_PROCESSING.hh"

using namespace std;

typedef vector<unsigned int> ui_vector;
typedef vector<double> d_vector;

int main(int argc,char **argv)
{
  assert(argc==4);
  bool output_dose(false);
  unsigned int n_cells,n_nodes,n_groups,n_values,flag;
  ui_vector offset;
  d_vector x,y,c_x,c_y,flux_moments,c_flux_moments,scalar_flux,dose;
  string output_file(argv[3]);
  output_file.append(".silo");

  if (strcmp(argv[1],"-p")==0)
  {
    cout<<"Input file created by the python code."<<endl;
    flag = 0;
  }
  else
  {
    if (strcmp(argv[1],"-t")==0) 
    {
      cout<<"Input file created by the transport c++ code."<<endl;
      flag = 1;
    }
    else
    {
      if (strcmp(argv[1],"-d")==0)
      {
        cout<<"Input file created by the diffusion c++ code."<<endl;
        flag = 2;
      }
      else
      {
        cout<<"Error wrong option."<<endl;
        assert(false);
      }
    }
  }

  cout<<"Start reading the input file."<<endl;

  // Open the file to read it
  ifstream file(argv[2],ios::in);

  assert(file);

  // Read the number of cells, the number of nodes and the number of values
  if (flag==0)
  {
    file>>n_cells>>n_nodes>>n_values;    
    n_groups = 1;
  }
  else
  {
    if (flag==1)
      file>>n_cells>>n_nodes>>n_groups>>n_values;    
    else
    {
      file>>n_cells>>n_nodes>>n_groups;
      n_values = n_nodes;
    }
  }

  // Resize the vectors
  offset.resize(n_cells+1,0);
  x.resize(n_nodes,0.);
  y.resize(n_nodes,0.);
  flux_moments.resize(n_groups*n_values,0.);
  if (flag!=2)
    scalar_flux.resize(n_groups*n_nodes,0.);

  // Read the offset
  for (unsigned int i=0; i<n_cells+1; ++i)
    file>>offset[i];
  // Read the coordinates of the nodes
  for (unsigned int i=0; i<n_nodes; ++i)
    file>>x[i]>>y[i];
  // Read the value of the flux moments
  for (unsigned int g=0; g<n_groups; ++g)
    for (unsigned int i=0; i<n_values; ++i)
      file>>flux_moments[g*n_values+i];

  if (flag==0)
    copy(flux_moments.begin(),flux_moments.end(),scalar_flux.begin());
  else
  {
    if (flag==1)
    {
      // If the file has been generated by the C++ code, it contains the scalar
      // flux and it may contain the dose
      string sigma_e;
      for (unsigned int g=0; g<n_groups; ++g)
        for (unsigned int i=0; i<n_nodes; ++i)
          file>>scalar_flux[g*n_values+i];
      file>>sigma_e;
      if (sigma_e.compare("true")==0)
      {
        output_dose = true;
        dose.resize(n_nodes,0.);
        for (unsigned int i=0; i<n_nodes; ++i)
          file>>dose[i];
      }
    }
    else
    {
      const unsigned int n_c_values(n_cells);
      c_x.resize(n_c_values,0.);
      c_y.resize(n_c_values,0.);
      c_flux_moments.resize(n_groups*n_c_values,0.);
      for (unsigned int i=0; i<n_c_values; ++i)
        file>>c_x[i]>>c_y[i];
      for (unsigned int g=0; g<n_groups; ++g)
        for (unsigned int i=0; i<n_c_values; ++i)
          file>>c_flux_moments[g*n_c_values+i];
    }
  }

  // Close the file
  file.close();
  
  cout<<"Done reading the input file."<<endl;

  if (flag!=2)
  {
    POST_PROCESSING post_process(output_dose,n_groups,&offset,&x,&y,&flux_moments,
        &scalar_flux,&dose,&output_file);

    cout<<"Start creating the silo file."<<endl;
    post_process.Create_transport_silo_file();
    cout<<"Done creating the silo file."<<endl;
  }
  else
  {
    POST_PROCESSING post_process(n_groups,&offset,&x,&y,&c_x,&c_y,
        &flux_moments,&c_flux_moments,&output_file);

    cout<<"Start creating the silo file."<<endl;
    post_process.Create_diffusion_silo_file();
    cout<<"Done creating the silo file."<<endl;
  }

  return 0;
}
